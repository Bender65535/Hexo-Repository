---
title: 垃圾收集器以及内存分配
date: 2019-09-10 11:02:06
tags: jvm
---

## 垃圾收集器

​		在jvm中,实现了多种垃圾收集器,包括:**串行垃圾收集器**,**并行垃圾收集器**,**CMS**(并发)垃圾收集器,**G1**垃圾收集器.

## 1.串行垃圾收集器

串行垃圾收集器,是指用单线程进行垃圾回收,垃圾回收时,**只有一个线程在工作**,并且java应用中的所有线程都要暂停,等待垃圾回收的完成,这种现象称之为SWT(Stop-The-World)

对于交互性较强的应用而言,这种垃圾收集器是不能够接受的

一般在javaweb中是不会采用该收集器的

<!--more-->

### 1.1设置垃圾回收为串行收集器

在程序运行参数中添加2个参数,如下:

+ -XX:+UseSerialGC
  + 指定年轻带和老年代都使用串行垃圾收集器
+ -XX:+PrintGCDetails
  + 打印打击回收的详细信息

## 2.并行的垃圾收集器

并行垃圾收集器在串行垃圾收集器的基础之上做了改进,将单线程**改为了多线程进行垃圾回收**,这样可以缩短垃圾回收的时间(这里是指,并行能力较强的机器)

当然了,并行垃圾收集器在垃圾收集的过程中也会暂停应用程序,这个和串行垃圾回收器是一样的,只是并行执行,速度更快些,暂停的时间更短一些

### 2.1ParNew垃圾收集器

ParNew垃圾收集器是工作在年轻代上的,只是将串行的垃圾收集器改为了并行

通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器,老年代使用的依然是串行收集器



### 2.2ParallelGC垃圾收集器

ParallelGC收集器工作机制和ParNewGC收集器一样,只是在此基础之上新增了两个和系统吞吐量相关的参数,使得其使用起来更加的灵活和高效

相关参数如下:

+ -XX:+UseParallelGC
  + 年轻代使用ParallelGC垃圾回收器,老年代使用串行回收器
+ -XX:+UseParallelOldGC
  + 年轻代使用ParallelGC垃圾回收器,老年代使用ParallelGC垃圾回收器
+ -XX:MaxGCPauseMillis
  + 设置最大的垃圾收集的停顿时间,单位为毫秒
  + 需要注意的是,ParallelGC为了达到设置的停顿时间,可能会调整堆大小或其他的参数,如果堆的大小设置的较小,就会导致GC工作变得很频繁,反而会影响到性能
  + 该参数使用需谨慎
+ -XX:GCTimeRatio
  + 设置垃圾回收时间占程序运行时间的百分比,公式为1/(1+n)
  + 它的值为0-100之间的数字,默认值为99,也就是垃圾回收时间不能超过1%
+ -XX:UseAdaptiveSizePolicy
  + 自适应GC模式,垃圾回收器将自动调整新生代,老年代参数,打到吞吐量,堆大小,停顿时间之间的平衡
  + 一般用于,手动调整参数比较困难的场景,让收集器自动进行调整



## 3.CMS垃圾收集器

CMS全称Concurrent Mark Sweep,是一款并发的,使用标记清除算法的垃圾回收器,该回收器是针对老年代垃圾回收的,通过参数-XX:+UseConcMarkSweepGC进行设置

CMS垃圾回收器的执行过程如下:

<img src="垃圾收集器以及内存分配\1568090863073.png" alt="1568090863073" style="zoom:80%;" />

+ 初始化标记(CMS-inital-marks),标记root,会导致stw
+ 并发标记(CMS-Concurrent-mark),与用户线程同时运行
+ 预清理(CMS-concurrennt-preclean),与用户线程同时运行
+ 重新标记(CMS-remark),会导致stw
+ 并发清除(CMS-concurrent-sweep),与用户线程同时运行
+ 调整堆大小,设置CMS在清理之后进行内存压缩,目的是清理内存中的碎片
+ 并发重置状态等待下次CMS的触发(CMS-concurrent-reset),与用户线程同时运行

## 4.G1垃圾收集器(重点)

G1垃圾收集器是在jdk1.7正式使用的全新的垃圾收集器,oracle官方计划在jdk9中将G1变成默认的垃圾啊收集器,以代替CMS

G1的设计原则就是简化JVM性能调优,开发人员只需要简单的三步即可完成调优:

+ 1.开启G1垃圾收集器
+ 2.设置堆的最大内存
+ 3.设置最大的停顿时间

G1中提供了3中垃圾回收模式,Young GC , Mixed GC 和Full GC , 在不同的条件下被触发

### 4.1原理

G1垃圾收集器相对比其他收集器而言,最大的区别在于它取消了年轻代和老年代的划分,取而代之的是将堆划分为若干区域(Region),这些区域中包含了有逻辑上的年轻代,老年代区域

这样做的好处就是,我们再也不用单独的空间对每个代进行设置了,不用担心每个代内存是否足够

<img src="垃圾收集器以及内存分配\1568091969623.png" alt="1568091969623" style="zoom:67%;" />

<img src="\垃圾收集器以及内存分配\1568092139767.png" alt="1568092139767" style="zoom:67%;" />

在G1划分的区域中,年轻代的垃圾收集依然采用暂停所有应用线程的方式,将存活对象拷贝到老年代或者Survivor空间,G1收集器通过将对象从一个区域复制到另一个区域,完成了清理工作

这就意味着,在正常的处理过程中,G1完成了堆的压缩(至少是部分堆的压缩),这样也就不会有CMS内存碎片问题的存在了

在G1中,有一种特殊的区域,叫Humongous(巨型对象)区域

+ 如果一个对象占用的空间超过了分区容量50%以上,G1收集器就认为这是一个巨型对象
+ 这些巨型对象,默认直接回呗分配在老年代,但是如果它是一个短期存在的巨型对象,就会对垃圾收集器造成负面影响
+ 为了解决这个问题,G1划分了一个Humongous区,它用来专门存放巨型对象,如果一个H区装不下一个巨型对象,那么G1会寻找到连续的H分区来存储,为了能找到连续的H区,有时不得不启动Full GC

### 4.2Young GC

Young GC主要是对Eden区进行GC,它在Eden空间耗尽时会被触发

+ Eden空间的数据移动到Survivor空间中,如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间.
+ Survivor区的数据移动到新的Survivor区中,也有部分数据晋升到老年代空间中
+ 最终Eden空间的数据为空,GC停止工作,应用线程继续执行

![1568096431880](垃圾收集器以及内存分配\1568096431880.png)

#### 4.2.1 Remembered Set(已记忆集合)

在GC年轻代的对象时,我们如何找到年轻代中对象的根对象呢?

根对象可能是在年轻代中,也可以在老年代中,那么老年代中的所有对象都是根么?

如果全量扫描老年代,那么这样扫描下来会耗费大量时间

于是,G1引进了RSet的概念,它的全称是Remembered Set,其作用是跟踪指向某个堆内的对象引用

<img src="\垃圾收集器以及内存分配\1568097149676.png" alt="1568097149676" style="zoom:67%;" />

每个Region初始化时,会初始化一个RSet,该集合用来记录并跟踪其它Region指向该Region中对象的引用,每个Region默认按照512kb划分成多个Card,所以RSet需要记录的东西应该是xx Region的xx Card

### 4.3Mixed GC

当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器,即Mixed GC,该算法并不是一个Old GC,除了回收整个Young Region,还会回收一部分的Old Region,这里需要注意:是一部分老年代,而不是全部老年代,可以选择哪些old region进行收集,从而可以对垃圾回收的耗时时间进行控制,也要注意的是Mixed GC 并不是Full GC Mixed GC什么时候触发?由参数**-XX:InitiatingHeapOccupancyPercent=n** 决定. 默认:45%,该参数的意思是:当老年代大小占整个堆大小百分比达到该阈值时触发.

它的GC步骤分2步:

+ 1.全局并发标记(global concurrent marking)
+ 2.拷贝存活对象(evacuation)