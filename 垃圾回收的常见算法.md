---
title: 垃圾回收的常见算法
date: 2019-09-10 09:09:04
tags: java , jvm
---

## 垃圾回收常见算法

自动化的管理内存资源,垃圾回收机制必须要有一套算法来进行计算,哪些是有效的对象,哪些是无效的对象,对于无效的对象就要进行回收处理

常见的垃圾算法有 : 引用计数法, 标记清除法, 标记压缩法, 复制算法, 分代算法

---

### 1.应用计数法

引用计数是历史最悠久的一种算法,最早George E. Collins在1960的时候提出,50年后的今天,该算法依然被很多编程语言引用

<!--more-->

### 1.1原理

假设一个对象A,任何一个对象(例如B对象)对A的引用,那么对象A的引用计数器+1,当引用失败时,对象A的引用计数器就-1,如果对象的计数器的值为0,就说明对象A没有了引用,可以被会回收

![1568078690464](垃圾回收的常见算法\1568078690464.png)

#### 1.2优缺点

优点:

+ 实用性较高,无需等到内存不够的时候,才开始回收,运行时根据对象的计数器是否为0,就可以直接回收
+ 在垃圾回收过程中,应用无需挂起,如果申请内存时,内存不足,则立刻报OOM错误
+ 区域性,更新对象的计数器时,只是影响到该对象,不会扫描全部对象

缺点:

+ 每次对象被引用时,都需要去更新计数器,有一点时间开销
+ 浪费CPU资源,即使内存够用,仍然在运行时进行计数器的统计
+ 无法解决循环引用问题(最大的缺点)

##### 什么是循环引用?

```java
class TestA{
    public TestB b;
}
class TestB{
    public TestA a;
}
public class Main{
    public static void main(String[] args){
        A a=new A();
        B b=new B();
        a.b=b;
        b.a=a;
        a=null;
        b=null;
    }
}
```

虽然a和b都为null,但是由于a和b存在循环引用,这样a和b永远都不会被回收.



### 2.标记清除法

标记清除算法,是将垃圾回收分为2个阶段,分别是标记和清除

+ 标记:从根节点开始标记引用对象
+ 清除:未被标记引用的对象就是垃圾对象,可以被清理

#### 2.1原理

<img src="垃圾回收的常见算法\1568079502068.png" alt="1568079502068"  />

这张图代表的是程序运行期间所有对象的状态(Root对象的引用指向,以及指向对象的指向),它们的标记位全部都是0(也就是未标记,一下默认0就是未标记,1为已标记),假设这回儿有效内存空间耗尽了,JVM将会停止应用程序的运行并开启GC线程,然后开始进行标记工作,按照根搜索算法,标记完以后,对象的状态如下图:

![1568079789567](垃圾回收的常见算法\1568079789567.png)

可以看到,按照根搜索算法,所有从root对象可达的对象就被标记为了存活对象,此时已经完成了第一阶段标记,接下来,就要执行第二阶段清除了,那么清除完以后,剩下的对象以及对象的状态如下图:

![1568079946586](垃圾回收的常见算法\1568079946586.png)

可以看到,没有被标记的对象将会回收清除掉,而被标记的对象将会留下,并且会将标记位重新归0,接下来唤醒停止的程序线程,让程序继续运行即可

#### 2.2优缺点

可以看到,标记清除算法解决了引用计数算法中的循环引用问题,没有从root节点引用的对象都会被回收,同样,标记清除算法也是有缺点的:

+ 效率较低,标记和清除两个动作都需要**遍历所有的对象**,并且在GC时,需要**停止应用程序**,对于交互性要求比较高的应用而言,这个体验是非常差的
+ 通过标记清除算法清理出来的内存,**碎片化严重**,因为被回收的对象可能存在于内存的各个角落,所以清理出来的内存是不连贯的,如图:

![1568081993592](垃圾回收的常见算法\1568081993592.png)

### 3.标记压缩算法

标记压缩算法是在标记清除算法的基础之上,做了优化改进的算法,和标记清除算法一样,也是从根节点开始,对对象的引用进行标记,在清理阶段,并不是简单的清理未标记的对象,而是**将存活的对象压缩到内存的一端**,然后清理边界以外的垃圾,从而解决了碎片化的问题

#### 3.1原理

<img src="垃圾回收的常见算法\1568082257456.png" alt="1568082257456" style="zoom: 67%;" />

#### 3.2优缺点

优缺点同标记清除算法,解决了标记清除算法的碎片化问题,同时,标记压缩算法多了一步,对象移动内存位置的步骤,其效率也有一定的影响

### 4.复制算法

复制算法的核心就是,将原有的内存空间一分为二,每次只用其中的一块,在垃圾回收时,将正在使用的对象复制到另一个内存空间中,然后将该内存空间清空,叫喊两个内存的角色,完成垃圾的回收.

如果内存中的垃圾对象较多,需要复制的对象就较少,这种情况下适合使用该方法并且效率比较高,反之,则不适合

![1568082948989](垃圾回收的常见算法\1568082948989.png)

![1568083019878](垃圾回收的常见算法\1568083019878.png)

#### 4.1原理

![1568083120122](垃圾回收的常见算法\1568083120122.png)

+ 在GC开始的时候,对象只会存在于Eden区和名为"From"的Survivor区,Survivor区"To"是空的
+ 在紧接着进行GC,Eden区中所有存活的对象都会被复制到"To",而在"From"区中,仍存活的对象会根据他们的年龄值来决定去向,年龄到达一定值(年龄阈值,可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到老年代中,没有达到阈值的对象会被复制到"To"区域中
+ 经过这次GC后,Eden区和From区已经被清空,这个时候,"From"和"To"会交换他们的角色,也就是新的"To"就是上次Gc前的"From",新的"From"就是上次GC前的"To",不管怎样,都会保证名为To的Survivor区域是空的
+ GC会一直重复这样的过程,知道"To"区域被填满,"To"去被填满之后,会将所有对象移动到年老代中

#### 4.2优缺点

优点:

+ 在垃圾对象多的情况下,效率较高
+ 清理后,内存无碎片

缺点:

+ 在垃圾对象少(存活的对象多)的情况下,不适用,如:年老代内存
+ 分配的2块内存空间,在同一时刻,只能使用一半,内存使用率较低

### 5.分代算法

前面介绍了多种回收算法,每一种算法都有自己的有点也有缺点,谁都不能替代谁,所以根据垃圾回收对象的特点进行选择,才是明智的选择

分代算法其实就是这样的,根据回收对象的特点进行选择,在jvm中,**年轻代适合使用复制算法**,**老年代适合使用标记清除或标记压缩算法**