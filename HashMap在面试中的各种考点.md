---
title: HashMap在面试中的各种考点
date: 2019-09-04 22:16:03
tags: java
---

### 为什么要容量要2的指数次幂?

hashcode的取模运算要换算成二进制,HashMap扩容后要移动所有下标都要移动位置,有需要进行取模运算

length=2的指数次幂的时候: hash%length==hash&(length-1),不为2的指数次幂时等式不满足

hash:       1001 0101 1000 0101 

length-1:  0000 0000 0000 1111 

当二者相与时,hashcode的范围必然会在0-15之间

HashMap的初始容量为16

初始长度必须是2的指数次幂,如果不是,就在调用put方法的时候把初始容量改成大于这个数的2的指数次幂的数(如:7-->8)

<!--more-->

### 为什么加载因子是0.75?

如果加载因子大于0.75,可以最大化利用空间,加载因子小于0.75时,不容易发生哈希冲突.折中后选择0.75效率最高



### 为什么HashMap的链表长度到8时才转为红黑树

元素放入HashMap中产生哈希碰撞满足泊松分布,当hashmap放入的元素越来越多时,就会扩容,这时发生碰撞的概率越来越低,通过计算,当hashmap的某个链的大小到达8的概率为0.00000006,再往上就越接近于0,这时可将链表树化,方便查找数据



### HashMap的扩容机制

当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容,loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize



### HashMap产生死锁的原因

JDK7在扩容把元素迁移到新的数组上时,在链表或树上的元素会形成一个闭环,当再次遍历扩容后的hashmap时就会死锁

在JDK8中,hashmap使用了高低位四个指针避免了扩容的死锁,但在多线程下还是会产生数据丢失